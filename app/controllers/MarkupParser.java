//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-10-11 21:23:31 GMT
//  from grammar '/home/ivar/minerva/app/controllers/MarkupGrammar.peg'.
//
//=========================================================================

package controllers;

import mouse.runtime.Source;

public class MarkupParser extends mouse.runtime.ParserBase
{
  final MarkupSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public MarkupParser()
    {
      sem = new MarkupSemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Post()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public MarkupSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Post = (Paragraph / Delimiter)* ;
  //=====================================================================
  private boolean Post()
    {
      begin("Post");
      while (Post_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Post_0 = Paragraph / Delimiter
  //-------------------------------------------------------------------
  private boolean Post_0()
    {
      begin("");
      if (Paragraph()) return acceptInner();
      if (Delimiter()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Paragraph = (!Delimiter (Link / Multispace / Newline / LongWord /
  //    Any))+ {paragraph} ;
  //=====================================================================
  private boolean Paragraph()
    {
      begin("Paragraph");
      if (!Paragraph_0()) return reject();
      while (Paragraph_0());
      sem.paragraph();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Paragraph_0 = !Delimiter (Link / Multispace / Newline / LongWord
  //    / Any)
  //-------------------------------------------------------------------
  private boolean Paragraph_0()
    {
      begin("");
      if (!Paragraph_1()) return rejectInner();
      if (!Link()
       && !Multispace()
       && !Newline()
       && !LongWord()
       && !Any()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Paragraph_1 = !Delimiter
  //-------------------------------------------------------------------
  private boolean Paragraph_1()
    {
      begin("","not Delimiter");
      if (Delimiter()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  LongWord = (!(Link / Multispace / Newline) ^[ ])+ {longword} ;
  //=====================================================================
  private boolean LongWord()
    {
      begin("LongWord");
      if (!LongWord_0()) return reject();
      while (LongWord_0());
      sem.longword();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LongWord_0 = !(Link / Multispace / Newline) ^[ ]
  //-------------------------------------------------------------------
  private boolean LongWord_0()
    {
      begin("");
      if (!LongWord_1()) return rejectInner();
      if (!nextNot(' ')) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  LongWord_1 = !(Link / Multispace / Newline)
  //-------------------------------------------------------------------
  private boolean LongWord_1()
    {
      begin("","not Link / Multispace / Newline");
      if (LongWord_2()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  LongWord_2 = Link / Multispace / Newline
  //-------------------------------------------------------------------
  private boolean LongWord_2()
    {
      begin("");
      if (Link()) return acceptInner();
      if (Multispace()) return acceptInner();
      if (Newline()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Newline = "\r"? "\n" {newline} ;
  //=====================================================================
  private boolean Newline()
    {
      begin("Newline");
      next('\r');
      if (!next('\n')) return reject();
      sem.newline();
      return accept();
    }
  
  //=====================================================================
  //  Any = _ {escape} ;
  //=====================================================================
  private boolean Any()
    {
      begin("Any");
      if (!next()) return reject();
      sem.escape();
      return accept();
    }
  
  //=====================================================================
  //  Delimiter = "\r"? "\n" [\t\r ]* "\n" ;
  //=====================================================================
  private boolean Delimiter()
    {
      begin("Delimiter");
      next('\r');
      if (!next('\n')) return reject();
      while (nextIn("\t\r "));
      if (!next('\n')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Multispace = " " " "+ {multispace} ;
  //=====================================================================
  private boolean Multispace()
    {
      begin("Multispace");
      if (!next(' ')) return reject();
      if (!next(' ')) return reject();
      while (next(' '));
      sem.multispace();
      return accept();
    }
  
  //=====================================================================
  //  Link = Alpha Alnum* "://" (LinkSymbols* OkEnd)* {link} ;
  //=====================================================================
  private boolean Link()
    {
      begin("Link");
      if (!Alpha()) return reject();
      while (Alnum());
      if (!next("://")) return reject();
      while (Link_0());
      sem.link();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Link_0 = LinkSymbols* OkEnd
  //-------------------------------------------------------------------
  private boolean Link_0()
    {
      begin("");
      while (LinkSymbols());
      if (!OkEnd()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  LinkSymbols = "-" / "." / "_" / "~" / ":" / "?" / "#" / "[" / "]" /
  //    "@" / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" /
  //    "=" / "%" ;
  //=====================================================================
  private boolean LinkSymbols()
    {
      begin("LinkSymbols");
      if (next('-')) return accept();
      if (next('.')) return accept();
      if (next('_')) return accept();
      if (next('~')) return accept();
      if (next(':')) return accept();
      if (next('?')) return accept();
      if (next('#')) return accept();
      if (next('[')) return accept();
      if (next(']')) return accept();
      if (next('@')) return accept();
      if (next('!')) return accept();
      if (next('$')) return accept();
      if (next('&')) return accept();
      if (next('\'')) return accept();
      if (next('(')) return accept();
      if (next(')')) return accept();
      if (next('*')) return accept();
      if (next('+')) return accept();
      if (next(',')) return accept();
      if (next(';')) return accept();
      if (next('=')) return accept();
      if (next('%')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  OkEnd = "/" / Alnum ;
  //=====================================================================
  private boolean OkEnd()
    {
      begin("OkEnd");
      if (next('/')) return accept();
      if (Alnum()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Alpha = [a-z] / [A-Z] ;
  //=====================================================================
  private boolean Alpha()
    {
      begin("Alpha");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Alnum = Alpha / Digit ;
  //=====================================================================
  private boolean Alnum()
    {
      begin("Alnum");
      if (Alpha()) return accept();
      if (Digit()) return accept();
      return reject();
    }
  
}
