//=========================================================================
//
//  This file was generated by Mouse 1.5 at 2012-10-14 10:44:35 GMT
//  from grammar
//    'C:\Users\Ivar\minerva\app\controllers\MarkupGrammar.peg'.
//
//=========================================================================

package controllers;

import mouse.runtime.Source;

public class MarkupParser extends mouse.runtime.ParserBase
{
  final MarkupSemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public MarkupParser()
    {
      sem = new MarkupSemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Post()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public MarkupSemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Post = (Paragraph / Delimiter)* {post} ;
  //=====================================================================
  private boolean Post()
    {
      begin("Post");
      while (Post_0());
      sem.post();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Post_0 = Paragraph / Delimiter
  //-------------------------------------------------------------------
  private boolean Post_0()
    {
      begin("");
      if (Paragraph()) return acceptInner();
      if (Delimiter()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Paragraph = (!Delimiter StartSpace)? (!Delimiter (Link /
  //    NewlineSpace / Multispace / Any))+ {paragraph} ;
  //=====================================================================
  private boolean Paragraph()
    {
      begin("Paragraph");
      Paragraph_0();
      if (!Paragraph_1()) return reject();
      while (Paragraph_1());
      sem.paragraph();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Paragraph_0 = !Delimiter StartSpace
  //-------------------------------------------------------------------
  private boolean Paragraph_0()
    {
      begin("");
      if (!Paragraph_2()) return rejectInner();
      if (!StartSpace()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Paragraph_1 = !Delimiter (Link / NewlineSpace / Multispace /
  //    Any)
  //-------------------------------------------------------------------
  private boolean Paragraph_1()
    {
      begin("");
      if (!Paragraph_2()) return rejectInner();
      if (!Link()
       && !NewlineSpace()
       && !Multispace()
       && !Any()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Paragraph_2 = !Delimiter
  //-------------------------------------------------------------------
  private boolean Paragraph_2()
    {
      begin("","not Delimiter");
      if (Delimiter()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Any = _ {escape} ;
  //=====================================================================
  private boolean Any()
    {
      begin("Any");
      if (!next()) return reject();
      sem.escape();
      return accept();
    }
  
  //=====================================================================
  //  Delimiter = "\r"? "\n" [\t\r ]* "\n" ;
  //=====================================================================
  private boolean Delimiter()
    {
      begin("Delimiter");
      next('\r');
      if (!next('\n')) return reject();
      while (nextIn("\t\r "));
      if (!next('\n')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Multispace = " " " "+ {multispace} ;
  //=====================================================================
  private boolean Multispace()
    {
      begin("Multispace");
      if (!next(' ')) return reject();
      if (!next(' ')) return reject();
      while (next(' '));
      sem.multispace();
      return accept();
    }
  
  //=====================================================================
  //  StartSpace = " " {startspace} ;
  //=====================================================================
  private boolean StartSpace()
    {
      begin("StartSpace");
      if (!next(' ')) return reject();
      sem.startspace();
      return accept();
    }
  
  //=====================================================================
  //  NewlineSpace = "\n " {newlinespace} ;
  //=====================================================================
  private boolean NewlineSpace()
    {
      begin("NewlineSpace");
      if (!next("\n ")) return reject();
      sem.newlinespace();
      return accept();
    }
  
  //=====================================================================
  //  Link = Alpha Alnum* "://" (LinkSymbols* OkEnd)* {link} ;
  //=====================================================================
  private boolean Link()
    {
      begin("Link");
      if (!Alpha()) return reject();
      while (Alnum());
      if (!next("://")) return reject();
      while (Link_0());
      sem.link();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Link_0 = LinkSymbols* OkEnd
  //-------------------------------------------------------------------
  private boolean Link_0()
    {
      begin("");
      while (LinkSymbols());
      if (!OkEnd()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  LinkSymbols = "-" / "." / "_" / "~" / ":" / "?" / "#" / "[" / "]" /
  //    "@" / "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" /
  //    "=" / "%" ;
  //=====================================================================
  private boolean LinkSymbols()
    {
      begin("LinkSymbols");
      if (next('-')) return accept();
      if (next('.')) return accept();
      if (next('_')) return accept();
      if (next('~')) return accept();
      if (next(':')) return accept();
      if (next('?')) return accept();
      if (next('#')) return accept();
      if (next('[')) return accept();
      if (next(']')) return accept();
      if (next('@')) return accept();
      if (next('!')) return accept();
      if (next('$')) return accept();
      if (next('&')) return accept();
      if (next('\'')) return accept();
      if (next('(')) return accept();
      if (next(')')) return accept();
      if (next('*')) return accept();
      if (next('+')) return accept();
      if (next(',')) return accept();
      if (next(';')) return accept();
      if (next('=')) return accept();
      if (next('%')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  OkEnd = "/" / Alnum ;
  //=====================================================================
  private boolean OkEnd()
    {
      begin("OkEnd");
      if (next('/')) return accept();
      if (Alnum()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Alpha = [a-z] / [A-Z] ;
  //=====================================================================
  private boolean Alpha()
    {
      begin("Alpha");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Alnum = Alpha / Digit ;
  //=====================================================================
  private boolean Alnum()
    {
      begin("Alnum");
      if (Alpha()) return accept();
      if (Digit()) return accept();
      return reject();
    }
  
}
